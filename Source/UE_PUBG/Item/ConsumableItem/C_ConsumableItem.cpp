// Fill out your copyright notice in the Description page of Project Settings.


#include "Item/ConsumableItem/C_ConsumableItem.h"

#include "GameFramework/CharacterMovementComponent.h"

#include "Character/C_Player.h"
#include "HUD/C_HUDWidget.h"
#include "Character/Component/C_EquippedComponent.h"
#include "Character/Component/C_ConsumableUsageMeshComponent.h"
#include "Character/Component/C_SwimmingComponent.h"
#include "Item/Weapon/C_Weapon.h"
#include "Item/Weapon/Gun/C_Gun.h"
#include "Utility/C_Util.h"

AC_ConsumableItem::AC_ConsumableItem()
{
	PrimaryActorTick.bCanEverTick = true;
}

void AC_ConsumableItem::BeginPlay()
{
	Super::BeginPlay();
}

void AC_ConsumableItem::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	UsingTimer += DeltaTime;

	switch (ConsumableItemState)
	{
	case EConsumableItemState::IDLE:
		UsingTimer = 0.f;
		return;
	case EConsumableItemState::ACTIVATING:
	{
		if (UsingTimer < UsageTime)
		{
			HandleActivatingState(); // Pure virtual Template method

			//방해 받았는지 체크해서 방해를 받았다면 Activating Cancel 시키기

			if (ItemUser->GetCharacterMovement()->IsFalling() || ItemUser->GetSwimmingComponent()->IsSwimming())
			{
				CancelActivating();
				return;
			}

			UAnimInstance* UserAnimInstance = ItemUser->GetMesh()->GetAnimInstance();

			for (auto& Pair : UsingMontageMap) if (UserAnimInstance->Montage_IsPlaying(Pair.Value.AnimMontage)) return;

			// 방해를 받음
			CancelActivating();

			return;
		}

		// Activating end

		if (AC_Player* Player = Cast<AC_Player>(ItemUser))
			Player->GetHUDWidget()->OnConsumableItemActivatingEnd();

		ConsumableItemState = EConsumableItemState::ACTIVATE_COMPLETED;
		UsingTimer = 0.f;

		if (ItemUser->GetEquippedComponent()->GetCurWeapon()) // 착용 중인 무기가 있었을 때
		{
			UC_EquippedComponent* UserEquippedComponent = ItemUser->GetEquippedComponent();

			ItemUser->GetEquippedComponent()->SetNextWeaponType(UserEquippedComponent->GetCurWeaponType());
			FPriorityAnimMontage DrawMontage = UserEquippedComponent->GetCurWeapon()->GetCurDrawMontage();
			ItemUser->PlayAnimMontage(DrawMontage);
		}

		OnActivatingFinish(); // Template method

		ItemUser->SetIsActivatingConsumableItem(false);
	}
		return;
	case EConsumableItemState::ACTIVATE_COMPLETED:
		HandleActivateCompletedState(); // Template Method
		return;
	case EConsumableItemState::USED:
	{
		if (AC_Player* Player = Cast<AC_Player>(ItemUser)) Player->GetHUDWidget()->OnConsumableUsed();

		ItemDatas.ItemStack--;

		if (ItemDatas.ItemStack == 0)
		{
			ItemUser->GetInvenComponent()->RemoveItemToMyList(this);
			HandleDestroy(); // 각 아이템 별 Destroy 하는 시점이 다름
			return;
		}

		ConsumableItemState = EConsumableItemState::IDLE;
	}
		return;
	default:
		return;
	}
}

bool AC_ConsumableItem::StartUsingConsumableItem(AC_BasicCharacter* InItemUser)
{
	if (!IsAvailableToStartUsing(InItemUser))				return false; // Template Method(IsAvaliableToStartUsing())
	if (InItemUser->GetSwimmingComponent()->IsSwimming())	return false;
	if (ConsumableItemState != EConsumableItemState::IDLE)	return false;

	ItemUser = InItemUser;

	if (ItemUser->GetIsActivatingConsumableItem())				return false;
	if (!UsingMontageMap.Contains(ItemUser->GetPoseState()))    return false;
	if (!UsingMontageMap[ItemUser->GetPoseState()].AnimMontage) return false;

	float PlayTime = ItemUser->PlayAnimMontage(UsingMontageMap[ItemUser->GetPoseState()]);

	// 다른 Montage에 의해 방해 받았을 때
	if (PlayTime == 0.f) return false;

	// 사용 시작하기
	ConsumableItemState = EConsumableItemState::ACTIVATING;
	OnStartUsing(); // Template method


	// 현재 들고 있는 무기가 존재한다면 무기 잠깐 몸 쪽에 붙이기
	if (AC_Weapon* UserWeapon = ItemUser->GetEquippedComponent()->GetCurWeapon())
	{
		UserWeapon->AttachToHolster(ItemUser->GetMesh());
		ItemUser->SetHandState(EHandState::UNARMED);

		// 총기류 예외처리
		if (AC_Gun* Gun = Cast<AC_Gun>(UserWeapon)) Gun->BackToMainCamera();
	}

	// 사용자의 bIsActivatingConsumableItem 세팅
	ItemUser->SetIsActivatingConsumableItem(true);

	//ItemDatas.ItemStack--;

	return true;
}

bool AC_ConsumableItem::CancelActivating()
{
	// TODO : 한 캐릭터 안에서 통용된 CancelActivating으로 수정해야 함

	if (ConsumableItemState != EConsumableItemState::ACTIVATING) return false;

	if (AC_Player* Player = Cast<AC_Player>(ItemUser))
		Player->GetHUDWidget()->OnCancelActivatingConsumableItem();

	UAnimInstance* UserAnimInstance = ItemUser->GetMesh()->GetAnimInstance();

	for (auto& Pair : UsingMontageMap)
	{
		if (UserAnimInstance->Montage_IsPlaying(Pair.Value.AnimMontage))
		{
			UserAnimInstance->Montage_Stop(0.2f, Pair.Value.AnimMontage);
			break;
		}
	}

	if (ItemUser->GetEquippedComponent()->GetCurWeapon()) // 착용 중인 무기가 있었을 때
	{
		UC_EquippedComponent* UserEquippedComponent = ItemUser->GetEquippedComponent();
		
		ItemUser->GetEquippedComponent()->SetNextWeaponType(UserEquippedComponent->GetCurWeaponType());
		FPriorityAnimMontage DrawMontage = UserEquippedComponent->GetCurWeapon()->GetCurDrawMontage();
		ItemUser->PlayAnimMontage(DrawMontage);
	}

	ItemUser->SetIsActivatingConsumableItem(false);
	OnCancelActivating();

	ConsumableItemState = EConsumableItemState::IDLE;
	UsingTimer			= 0.f;
	//ItemUser			= nullptr;

	return true;
}

bool AC_ConsumableItem::Interaction(AC_BasicCharacter* Character)
{

	switch (ItemDatas.ItemPlace)
	{
	case EItemPlace::AROUND:
		if (!OwnerCharacter) return MoveToInven(Character);
	case EItemPlace::INVEN:
		return StartUsingConsumableItem(Character);
		//break;
	default:
		return false;
	}
}

bool AC_ConsumableItem::MoveToInven(AC_BasicCharacter* Character)
{
	UC_InvenComponent* invenComp = Character->GetInvenComponent();
	UC_EquippedComponent* equipComp = Character->GetEquippedComponent();

	uint8 ItemStackCount = invenComp->LoopCheckVolume(this);

	if (ItemStackCount == 0)
	{
		UC_Util::Print("Not Enough Volume");
		return false; //인벤에 넣을 수 있는 아이템의 갯수가 0 이면 넣을 수 없으므로 return false;
	}

	AC_Item* FoundItem = invenComp->FindMyItem(this); //인벤에 같은 아이템을 찾아옴, 없다면 nullptr;

	if (ItemDatas.ItemStack == ItemStackCount)
	{
		//아이템 전부를 인벤에 넣을 수 있을 때.
		if (IsValid(FoundItem))
		{
			//인벤에 해당 아이템이 존재 할 때.
			FoundItem->SetItemStack(FoundItem->GetItemDatas().ItemStack + ItemStackCount);
			//invenComp->GetCurVolume() += FoundItem->GetItemDatas().ItemVolume * ItemStackCount;
			//TODO : destroy를 해도 잔상이 남는것을 대비해서 해놓음 만약 없이도 잔상이 안남는다면 지울 것.
			invenComp->AddInvenCurVolume(this->ItemDatas.ItemVolume * ItemStackCount);

			this->SetActorEnableCollision(false);
			this->SetActorHiddenInGame(true);

			this->Destroy();
			return true;
		}
		else
		{
			//인벤에 해당 아이템이 존재하지 않을 때.
			invenComp->AddItemToMyList(this);
			//인게임에서 보이는 것과 collision문제 때문에 임시로 꺼둠.
			//this->SetActorEnableCollision(false);
			this->SetActorHiddenInGame(true);
			//던질 때 켜짐. 이걸로 만약 아이템의 오버랩이 안끝난다면 다른 방법 고민->ToInven에서 SetActorEnableCollision를 꺼주고 던질때 혹은 ToAround에서 켜주기.
			//Collider->SetCollisionEnabled(ECollisionEnabled::NoCollision);
			return true;
		}
	}
	else
	{
		//아이템의 일부만 인벤에 넣을 수 있을 때.
		if (IsValid(FoundItem))
		{
			this->SetItemStack(ItemDatas.ItemStack - ItemStackCount);
			FoundItem->SetItemStack(FoundItem->GetItemDatas().ItemStack + ItemStackCount);

			invenComp->AddInvenCurVolume(this->ItemDatas.ItemVolume * ItemStackCount);

			return true;
		}
		else
		{
			AC_Weapon* NewItem = Cast<AC_Weapon>(SpawnItem(Character));//아이템 복제 생성
			NewItem->SetItemStack(ItemStackCount);
			this->SetItemStack(ItemDatas.ItemStack - ItemStackCount);

			invenComp->AddItemToMyList(NewItem);

			NewItem->SetActorHiddenInGame(true);
			//collider 관련 설정 추가해야 할 수 있음.
			//만약 추가해야 된다면 MoveToInven에서 SetActorEnableCollision을 꺼주고 던질 때 켜주는 방식으로.
			return true;
		}
	}
}

bool AC_ConsumableItem::MoveToSlot(AC_BasicCharacter* Character)
{
	return false;
}

bool AC_ConsumableItem::MoveToAround(AC_BasicCharacter* Character)
{
	if (!Character) return false;

	Character->GetInvenComponent()->RemoveItemToMyList(this);
	//TODO: 분할해서 버리는 경우 새로 스폰해주어야함.
	ItemDatas.ItemPlace = EItemPlace::AROUND;
	SetOwnerCharacter(nullptr);
	SetActorHiddenInGame(false);
	SetActorEnableCollision(true);
	//Collider->SetCollisionEnabled(ECollisionEnabled::QueryOnly);

	//바닥 레이 캐스팅 받아와서 바닥에 아이템 생성하기.
	SetActorLocation(GetGroundLocation(Character) + RootComponent->Bounds.BoxExtent.Z);

	//SetActorRotation(FQuat(0,0,0));

	return true;
}
